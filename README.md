# Push Notify - 智能代码推送通知系统

## 系统概述

Push Notify 是一款智能代码推送通知管理系统，旨在帮助开发团队在用户提交代码到代码仓库时，自动进行代码审查（CODEVIEW）并通过多种渠道（钉钉、邮箱等）推送代码变更通知和审查结果。

本系统采用前后端分离架构，前端使用 Vue3 框架构建现代化用户界面，后端使用 Golang Gin 框架提供高性能 RESTful API 服务。通过智能化的代码审查提示词配置和灵活的消息模板管理，系统能够帮助团队实现高效的代码审查流程和及时的通知推送。

## 功能特性

### 1. 仓库管理
- 支持配置和管理代码仓库信息
- 集成代码仓库 webhook，实现自动触发代码审查
- 支持多种代码仓库类型（GitHub、GitLab 等）
- 可配置仓库的审查规则和触发条件

### 2. 推送目标管理
- **钉钉推送**：支持配置钉钉机器人，实现代码审查结果实时推送到钉钉群
- **邮箱推送**：支持配置 SMTP 邮箱服务，将代码变更通知发送到指定邮箱
- 灵活的推送目标分组和优先级设置
- 支持按仓库或按项目配置推送目标

### 3. 推送内容查询
- 提供完善的推送记录查询功能
- 支持按时间范围、仓库、推送状态等条件筛选
- 推送内容的详细展示，包括变更文件、审查结果等
- 推送状态追踪和失败重试机制

### 4. AI 模型管理
- 支持配置和管理 AI 模型接口
- 可对接多种 AI 服务提供商
- 模型参数配置（温度、最大Token等）
- 模型调用日志和成本统计

### 5. 用户管理
- 用户注册和登录认证
- 基于角色的访问控制（RBAC）
- 用户权限分配和管理
- 用户操作日志记录

### 6. 日志管理
- 系统运行日志全面记录
- 推送日志详细追踪
- AI 模型调用日志
- 日志搜索和导出功能

### 7. 推送消息模板管理
- 可视化消息模板编辑
- 支持变量替换（代码变更内容、审查结果等）
- 模板预览和测试功能
- 多模板版本管理

### 8. 提示词管理
- **CODEVIEW 提示词**：配置 AI 代码审查的提示词模板
- **推送消息提示词**：配置推送消息生成的提示词
- 提示词变量支持
- 提示词效果分析和优化建议

## 技术架构

### 前端技术栈

| 技术 | 用途 |
|------|------|
| Vue 3 | 前端核心框架 |
| naive-ui | UI 组件库 |
| tailwindcss | 原子化 CSS 样式框架 |
| axios | HTTP 请求库 |
| vue-router | 路由管理 |
| vite | 构建工具 |
| pinia | 状态管理 |
| pinia-plugin-persistedstate | 状态持久化 |
| JavaScript | 开发语言 |

### 后端技术栈

| 技术 | 用途 |
|------|------|
| Golang | 开发语言 |
| Gin | Web 框架 |
| GORM | ORM 框架 |
| SQLite (glebarez/sqlite) | 轻量级数据库 |
| Redis | 缓存和会话存储 |

### 系统架构图

```
┌─────────────────────────────────────────────────────────────┐
│                      客户端浏览器                            │
└─────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────┐
│                     Vue3 前端应用                            │
│  ┌───────────┐  ┌───────────┐  ┌───────────┐              │
│  │ 仓库管理  │  │ 推送管理  │  │ 用户管理  │              │
│  └───────────┘  └───────────┘  └───────────┘              │
└─────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────┐
│                    Golang Gin 后端                          │
│  ┌───────────┐  ┌───────────┐  ┌───────────┐              │
│  │ REST API  │  │ 业务逻辑  │  │ 权限控制  │              │
│  └───────────┘  └───────────┘  └───────────┘              │
└─────────────────────────────────────────────────────────────┘
                              │
              ┌───────────────┼───────────────┐
              ▼               ▼               ▼
       ┌──────────┐    ┌──────────┐    ┌──────────┐
       │ SQLite   │    │  Redis   │    │ AI 模型  │
       │ 数据库   │    │  缓存    │    │  接口    │
       └──────────┘    └──────────┘    └──────────┘
                              │
                              ▼
              ┌───────────────┼───────────────┐
              ▼               ▼               ▼
       ┌──────────┐    ┌──────────┐    ┌──────────┐
       │ 钉钉机器人│    │  邮箱    │    │  代码    │
       │ Webhook  │    │  SMTP    │    │  仓库    │
       └──────────┘    └──────────┘    └──────────┘
```

## 快速开始

### 环境要求

- Node.js 16+
- Go 1.20+
- SQLite 3
- Redis 6+

### 一键构建（集成前端静态资源）

项目支持将前端编译后的静态资源打包到后端 Go 二进制文件中，实现单文件部署。

#### Windows 环境
在项目根目录下运行 PowerShell 脚本：
```powershell
.\build.ps1
```
构建完成后，会在根目录生成 `push-notify.exe`。

#### 非 Windows 环境 (手动步骤)
1. 进入 `frontend` 目录并构建：
   ```bash
   cd frontend
   npm install
   npm run build
   ```
2. 将 `frontend/dist` 目录复制到 `backend/static/dist`：
   ```bash
   cp -r frontend/dist backend/static/
   ```
3. 进入 `backend` 目录并构建：
   ```bash
   cd backend
   go build -o ../push-notify main.go
   ```

### 前端开发安装步骤

1. **克隆项目**

```bash
git clone <repository-url>
cd push_notify
```

2. **安装依赖**

```bash
npm install
```

3. **配置环境变量**

创建 `.env` 文件并配置以下内容：

```env
VITE_API_BASE_URL=http://localhost:8080
```

4. **启动开发服务器**

```bash
npm run dev
```

5. **构建生产版本**

```bash
npm run build
```

### 后端安装步骤

1. **进入后端目录**

```bash
cd server
```

2. **初始化数据库**

```bash
go run main.go migrate
```

3. **配置环境变量**

创建 `.env` 文件并配置以下内容：

```env
# 服务配置
PORT=8080
MODE=debug

# 数据库配置
DB_PATH=./data.db

# Redis配置
REDIS_HOST=localhost
REDIS_PORT=6379
REDIS_PASSWORD=

# AI模型配置
AI_API_KEY=your-api-key
AI_MODEL=gpt-4

# 钉钉配置
DINGTALK_ACCESS_TOKEN=
DINGTALK_SECRET=

# 邮箱配置
SMTP_HOST=smtp.example.com
SMTP_PORT=587
SMTP_USERNAME=
SMTP_PASSWORD=
```

4. **启动服务**

```bash
go run main.go
```

### 访问系统

- 前端访问：http://localhost:3000
- 后端 API：http://localhost:8080

## 使用指南

### 仓库管理

1. 进入「仓库管理」页面
2. 点击「添加仓库」按钮
3. 填写仓库配置信息：
   - 仓库名称
   - 仓库地址（Git URL）
   - 仓库类型（GitHub/GitLab）
   - Webhook 地址（用于接收代码提交事件）
   - 审查规则配置
4. 保存配置后，系统将自动监听该仓库的代码提交事件

### 推送目标配置

#### 配置钉钉推送

1. 进入「推送目标管理」页面
2. 点击「添加推送目标」
3. 选择「钉钉」类型
4. 配置钉钉机器人：
   - 钉钉群 Access Token
   - 钉钉机器人 Secret（可选，用于签名验证）
5. 保存配置

#### 配置邮箱推送

1. 进入「推送目标管理」页面
2. 点击「添加推送目标」
3. 选择「邮箱」类型
4. 配置邮箱信息：
   - SMTP 服务器地址
   - SMTP 端口
   - 发件人邮箱
   - 发件人密码/授权码
5. 保存配置

### 消息模板管理

1. 进入「消息模板管理」页面
2. 点击「新建模板」
3. 配置模板内容：
   - 模板名称
   - 模板类型（钉钉/邮箱）
   - 模板内容（支持变量替换）
   - 变量说明：
     - `{{.RepoName}}` - 仓库名称
     - `{{.CommitMsg}}` - 提交信息
     - `{{.ChangedFiles}}` - 变更文件列表
     - `{{.CodeViewResult}}` - 代码审查结果
4. 保存模板并启用

### 提示词配置

#### CODEVIEW 提示词

1. 进入「提示词管理」页面
2. 找到「CODEVIEW 提示词」配置
3. 编辑提示词模板，定义 AI 代码审查的规则和要求
4. 支持的变量：
   - `{{.FileName}}` - 文件名
   - `{{.FileContent}}` - 文件内容
   - {{.DiffContent}}` - 代码差异内容

### AI 模型配置

1. 进入「AI 模型管理」页面
2. 点击「添加模型」
3. 配置模型信息：
   - 模型名称
   - API 地址
   - API Key
   - 模型参数（温度、最大 Token 等）
4. 保存配置并设置为默认模型

### 用户管理

1. 管理员可在「用户管理」页面添加新用户
2. 为用户分配角色（管理员、普通用户）
3. 用户的权限通过角色进行控制

## API 文档

### 基础信息

- Base URL: `/api/v1`
- 认证方式: Bearer Token

### 仓库接口

| 方法 | 路径 | 描述 |
|------|------|------|
| GET | /api/v1/repos | 获取仓库列表 |
| POST | /api/v1/repos | 创建仓库 |
| GET | /api/v1/repos/:id | 获取仓库详情 |
| PUT | /api/v1/repos/:id | 更新仓库 |
| DELETE | /api/v1/repos/:id | 删除仓库 |

### 推送目标接口

| 方法 | 路径 | 描述 |
|------|------|------|
| GET | /api/v1/targets | 获取推送目标列表 |
| POST | /api/v1/targets | 创建推送目标 |
| GET | /api/v1/targets/:id | 获取推送目标详情 |
| PUT | /api/v1/targets/:id | 更新推送目标 |
| DELETE | /api/v1/targets/:id | 删除推送目标 |

### 消息模板接口

| 方法 | 路径 | 描述 |
|------|------|------|
| GET | /api/v1/templates | 获取模板列表 |
| POST | /api/v1/templates | 创建模板 |
| GET | /api/v1/templates/:id | 获取模板详情 |
| PUT | /api/v1/templates/:id | 更新模板 |
| DELETE | /api/v1/templates/:id | 删除模板 |

### 推送记录接口

| 方法 | 路径 | 描述 |
|------|------|------|
| GET | /api/v1/pushes | 获取推送记录 |
| GET | /api/v1/pushes/:id | 获取推送详情 |
| POST | /api/v1/pushes/:id/retry | 重试失败推送 |

## 常见问题

### Q: 如何配置代码仓库的 Webhook？

A: 在仓库管理页面添加仓库后，系统会生成对应的 Webhook URL。将此 URL 配置到代码仓库的 Webhook 设置中，并选择 Push 事件作为触发条件。

### Q: 推送失败后如何重试？

A: 进入「推送内容查询」页面，找到失败的推送记录，点击「重试」按钮即可重新发送。

### Q: 如何自定义推送消息格式？

A: 进入「消息模板管理」页面，编辑相应的模板。系统支持使用 `{{.变量名}}` 语法插入动态内容。

## 许可证

本项目采用 MIT 许可证开源。

## 贡献指南

欢迎贡献代码、报告问题或提出功能建议。请通过 GitHub Issues 或 Pull Requests 进行贡献。
